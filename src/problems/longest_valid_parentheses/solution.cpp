class Solution {
public:
    int longestValidParentheses(string s) {
        /*
        1. 如果有連續的()存在，那麼加上dp[i-2]位置的最大值可以得到當前位置最大值，假設dp[i-2]是有連續
            的大小存在'('或')'，那麼就會延續; 如果被中斷，且不可能接上的')'，那就是局部的最大值。
        2. 如果出現連續))存在，那麼要找到當前')'配對的'('是否存在可以是if s[i-dp[i-1]-1]=='('
            因為假設dp[i-1]沒有值，就代表左邊沒有可配對的'('; 如果有值，代表左邊局部')'最大值是配對
            過的，所以減去看還有沒有'('。
            ex1: ((()))一直到最中間的')'才會有值2代表2個長度，後面的就會減去這個2
            ex2: "()(())"要判斷，找到也要接上前面的長度
        */
        // 多一個在開頭空格是為了讓-2不用多判定，開頭為')'沒有必要判斷
        s.insert(0, 1, ')');  // O(n)
        vector<int> dp(s.size()+1);

        int max_length = 0;
        for (int i = 1; i <= s.size(); ++i) {
            if (s[i] == ')') {
                if (s[i-1] == '(') {
                    dp[i] = dp[i-2] + 2;
                }
                else if (s[i-1-dp[i-1]] == '(') {
                    dp[i] = dp[i-1] + 2;  // ((()))
                    dp[i] += i-2-dp[i-1] > 0 ? dp[i-2-dp[i-1]] : 0;  // "()(())"要判斷
                }
                else {  // ()()())
                    // 斷掉的長度
                }

                max_length = max(max_length, dp[i]);
            }
        }

        return max_length;
    }
};